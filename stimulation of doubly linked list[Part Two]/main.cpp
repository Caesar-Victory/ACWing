#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int m;
int e[N], l[N], r[N], idx;

// 注意所有节点的删除，添加都是右边的指针先伸手

void init(void) {

    // 初始化时，两个节点的下标分别为0， 1；
    // 分别用0， 1的左右指针指向这两个值
    r[0] = 1, l[1] = 0;
    // 由于下标0，1均已分配，因此初始下标为2
    idx = 2;
}

// 在 K 节点的前面插入一个元素，其值为 x
void add_left(int k, int x) {

    // 先用链表将数值存储起来
    e[idx] = x;
    // 新节点的右指针指向 K 节点
    r[idx] = k;
    // 新节点的左指针指向 K 左边的节点
    l[idx] = l[k];
    // 注意，应该先移动右边的指针，同时，如果一个点的左右指针要被当作下标的话，先不要修改指针本身，先使用依靠指针作为下标的功能
    // k 节点的左边节点，它的右指针指向新建节点
    r[l[k]] = idx;
    // K 节点的右指针，指向新建节点
    l[k] = idx;
}

// 在 K 节点的后面插入一个元素，其值为 x
void add_right(int k, int x) {

    // 先用链表将数值存储起来，然后再构建双链
    e[idx] = x;
    //插入节点的右指针先伸手,新节点的右指针我们不知道，只知道它在 K 的右边，以K为下标，从右指针取值
    r[idx] = r[k];
    // 新插入节点的左边我们知道，就是给定的K，因此新节点，存储右边节点的指针，直接以当前下标为基准，存储K
    l[idx] = k;
    // 由于我们需要 r[k]定位，也就是K节点的右指针存储的值，所以再完成新节点向两边握手之后
    // 先让 K 右边的节点，向左指向新建节点
    l[r[k]] = idx;
    // 再让K节点的右指针，指向新建节点
    r[k] = idx;
}

void remove(int k) {

    // 当建立链接关系时，应当以当前节点K的左右指针为基准，进行K左右节点，这俩节点的移动
    r[l[k]] = r[k];
    // 当前节点的左指针，这个指针充当左节点，将这个节点的右指针，指向K节点右指针指向的值
    l[r[k]] = l[k];
    // 当前节点的右指针，这个指针充当右节点，将这个节点的左指针，指向K节点左指针指向的值
}

int main() {


}